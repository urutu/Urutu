# Developed by Aditya Atluri
# Date: 18 Jan 2014
# This file converts Python code to CUDA code
# Modified: 22 Jan 2015

import shlex,inspect
from inspect import getcallargs
import numpy as np
import execu
import threads, blocks, declare, grammar, modules
import device

class ur_cuda:

	# numpy arguments given to GPU function
	arguments = []

	# numpy data type arrays that are returned to the calling function
	returns = []

	# name of variables in the Urutu function scope
	var_nam = []

	# value of variables declared inside Urutu function
	var_val = []

	# the final kernel
	kernel_final = []

	# The name of args that are given to pycuda for allocation and execution
	kernel_args = ""

	# The 
	kernel = "/*This is callable CUDA kernel code generated by Urutu*/\n"
	device = "/*This is the device code*/\n"
	threads = [1, 1, 1]
	threads_dec = [False, False, False]
	blocks = [1, 1, 1]
	blocks_dec = [False, False, False]
	global_func = []
	code = ""
	args = []
	type_args = []
	type_vars = []
	words = []
	sentences = []
	__global = []
	__shared = []
	__register = []
	__constant = []
	ismap = []
	tabs = 0
	count_def = 0
	num_return = 0
	count_return = 0
	is_device_code = False
	device_py = [[]]
	device_tab = 0
	device_body_buff = ""
	device_func_name = []
	device_var_nam = [[]]
	device_type_vars = [[]]
	device_scope = False
	device_sentences = [[]]
	device_threads_dec = [False,False,False]
	device_blocks_dec = [False, False, False]
	device_num_threads = []
	device_num_blocks = []
	device_dyn_p = False
	arg_nam = [""]
	return_kernel = False
	modules = []
	is_defined_device = []
	is_shared = False
	num_mod = 0
	map_func = []
	moved = []
	cuda_exe = 0
#The structure is a tuple {'order of calling':,'line number':,'return':,'source':, 'args':,'htod':, 'dtoh':, }
	cpu_empty = {'id':0, 'ln':0, 'return':[], 'src':"", 'args': [], 'htod': [], 'dtoh': [], 'isnext': False}
	cpu_id = 0
	cpu_info = []
	gpu_id = 1

	def __init__(self, fn, args):
		stri = inspect.getsource(fn)
		sh = shlex.shlex(stri)
		self.code = stri
		if type(args[0]) is list and type(args[1]) is not list:
			self.threads = args[0]
			self.args = args[1:]
		if type(args[0]) is list and type(args[1]) is list:
			self.threads = args[0]
			self.blocks = args[1]
			self.args = args[2:]
		if args[0] == True:
			self.return_kernel = True
			self.args = args[1:]
		self.typeargs()

	def decarrays(self, phrase):
#		print phrase
		if phrase[0] == '__global' and phrase[1] == 'is':
			phrase.pop(0)
			for word in phrase:
				if word != ',':
					self.__global.append(word)
#			print self.__global
		if phrase[0] == '__shared' and phrase[1] == 'is':
			self.is_shared = True
			phrase.pop(0)
			for word in phrase:
				if word != ',':
					self.__shared.append(word)
#			print self.__shared
		if phrase[0] == '__register' and phrase[1] == 'is':
			phrase.pop(0)
			for word in phrase:
				if word != ',':
					self.__register.append(word)
#			print self.__register
		if phrase[0] == '__constant' and phrase[1] == 'is':
			phrase.pop(0)
			for word in phrase:
				if word != ',':
					self.__constant.append(word)
#			print self.__constant

	def typeargs(self):
		for arg in self.args:
			try:
				j = str(type(arg[0])).split("'")
			except:
				j = str(type(arg)).split("'")
			if 'numpy' in j[1]:
				j = j[1].split(".")
				self.type_args.append(j[1]+"*")
				self.type_vars.append(j[1]+"*")
			else:
				self.type_args.append(j[1])
				self.type_vars.append(j[1])

	def funcname_cu(self,control):
		func_name = self.keys[control + 1]
		self.kernel = self.kernel+"__global__ void " + func_name + "_1("
		self.ismap.append(False)
		self.global_func = func_name
		self.count_def = 1
		return control + 2
#		Return whether it is pass by reference or 

	def semi_colon(self,phrase):
		self.kernel = self.kernel + phrase + ";\n"

	def declare_workitems(self,keys,kernel):
#		The keys are strings
#		print "\n\nDEC_WORKITEMS", keys, self.device_threads_dec, self.device_blocks_dec
		if keys.find('tx') > -1:
			kernel, self.device_threads_dec[0] = threads.tx(self.device_threads_dec[0], kernel)
		if keys.find('ty') > -1:
			kernel, self.device_threads_dec[1] = threads.ty(self.device_threads_dec[1], kernel)
		if keys.find('tz') > -1:
			kernel, self.device_threads_dec[2] = threads.tz(self.device_threads_dec[2], kernel)
		if keys.find('bx') > -1:
			kernel, self.device_blocks_dec[0] = blocks.bx(self.device_blocks_dec[0], kernel)
		if keys.find('bx') > -1:
			kernel, self.device_blocks_dec[1] = blocks.by(self.device_blocks_dec[1], kernel)
		if keys.find('bz') > -1:
			kernel, self.device_blocks_dec[2] = blocks.bz(self.device_blocks_dec[2], kernel)
		return kernel

	def remove_workitems(self):
		if self.var_nam.count('tx') > 0:
			self.var_nam.remove('tx')
		if self.var_nam.count('ty') > 0:
			self.var_nam.remove('ty')
		if self.var_nam.count('tz') > 0:
			self.var_nam.remove('tz')
		if self.var_nam.count('bx') > 0:
			self.var_nam.remove('bx')
		if self.var_nam.count('by') > 0:
			self.var_nam.remove('by')
		if self.var_nam.count('bz') > 0:
			self.var_nam.remove('bz')
		if self.var_nam.count('Tx') > 0:
			self.var_nam.remove('Tx')
		if self.var_nam.count('Ty') > 0:
			self.var_nam.remove('Ty')
		if self.var_nam.count('Tz') > 0:
			self.var_nam.remove('Tz')
		if self.var_nam.count('Bx') > 0:
			self.var_nam.remove('Bx')
		if self.var_nam.count('By') > 0:
			self.var_nam.remove('By')
		if self.var_nam.count('By') > 0:
			self.var_nam.remove('By')

	def inspect_it(self,sentence,kernel):
#		print "Inside inspect_it()",sentence,kernel
		phrase = sentence.split('\t')
		if phrase.count('#') > 0:
			return
		tab = phrase.count('')
		if tab < self.tabs and self.device_scope == False:
			for j in range(self.tabs - tab):
				kernel += "}\n"
		self.tabs = phrase.count('')
		sh = shlex.shlex(phrase[-1])
		i = sh.get_token()
		if i == '@' or i == 'def' or i == '' or i == '#' or i == '//' or i == '"""':
			return kernel
		stmt = []
		while i is not sh.eof:
			stmt.append(i)
			i = sh.get_token()
		if stmt.count('and') > 0:
			stmt[stmt.index('and')] = " && "
		if self.keys.count('tx') > 0 and self.var_nam.count('tx') == 0:
			kernel, self.threads_dec[0] = threads.tx(self.threads_dec[0], kernel)
			self.var_nam.append("tx")
			self.type_vars.append("int")
		if self.keys.count('ty') > 0 and self.var_nam.count('ty') == 0:
			kernel, self.threads_dec[1] = threads.ty(self.threads_dec[1], kernel)
			self.var_nam.append("ty")
			self.type_vars.append("int")
		if self.keys.count('tz') > 0 and self.var_nam.count('tz') == 0:
			kernel, self.threads_dec[2] = threads.tz(self.threads_dec[2], kernel)
			self.var_nam.append("tz")
			self.type_vars.append("int")
		if self.keys.count('bx') > 0 and self.var_nam.count('bx') == 0:
			kernel, self.blocks_dec[0] = blocks.bx(self.blocks_dec[0], kernel)
			self.var_nam.append("bx")
			self.type_vars.append("int")
		if self.keys.count('by') > 0 and self.var_nam.count('by') == 0:
			kernel, self.blocks_dec[1] = blocks.by(self.blocks_dec[1], kernel)
			self.var_nam.append("by")
			self.type_vars.append("int")
		if self.keys.count('bz') > 0 and self.var_nam.count('bz') == 0:
			kernel, self.blocks_dec[2] = blocks.bz(self.blocks_dec[2], kernel)
			self.var_nam.append("bz")
			self.type_vars.append("int")
		if stmt.count('Tx') == 1 or stmt.count('Ty') == 1 or stmt.count('Tz') == 1:
			self.var_nam, self.var_val, self.threads, ker, self.type_vars= threads.threads_decl(stmt, self.var_nam, self.var_val, self.threads, self.type_vars)
			kernel += ker
			if stmt.count('=') > 0:
				id_eq = stmt.index('=')
				type_, ptr_, var_, val_ = self.checktype(stmt[:id_eq],stmt[id_eq+1:])
				self.var_nam.append(ptr_)
				self.type_vars.append(type_)
				kernel += type_+ptr_+var_ + "= " + val_ +";\n"
				return kernel
		if stmt.count('Bx') == 1 or stmt.count('By') == 1 or stmt.count('Bz') == 1:
			self.var_nam, self.var_val, self.blocks, ker, self.type_vars = blocks.blocks_decl(stmt, self.var_nam, self.var_val, self.blocks, self.type_vars)
			kernel += ker
			if stmt.count('=') > 0:
				id_eq = stmt.index("=")
				type_, ptr_, var_, val_ = self.checktype(stmt[:id_eq],stmt[id_eq+1:])
				self.type_vars.append(type_)
				self.var_nam.append(ptr_)
				kernel += type_ + ptr_ + var_ + "= " + val_ +";\n"
				return kernel
		for j in self.device_func_name:
			if stmt.count(j) > 0:
				kernel += self.device_create_func(self.device_func_name.index(j),j, stmt)
				kernel = self.device_body_buff + "}\n" + kernel
				self.device_body_buff = ""
				return kernel
		if stmt[0] == '__global' or stmt[0] == '__shared' or stmt[0] == '__register' or stmt[0] == '__constant' :
			self.decarrays(stmt)
			return kernel
		if stmt.count('for') > 0:
			kernel += self._for(stmt, kernel)
			return kernel
		if stmt.count('if') > 0:
			return kernel + grammar.keyword(stmt, kernel)
		if stmt.count('else') > 0:
			kernel = kernel + "else{\n"
			return kernel
		if stmt.count('cpu') > 0:
			self.kernel_final.append(kernel+"}")
			cpu_empty = {'id':0, 'ln':0, 'return':[], 'src':"", 'args': [], 'htod': [], 'dtoh': []}
			self.cpu_id = self.cpu_id + 1
			cpu_empty['id'] = self.cpu_id
			cpu_empty['ln'] = self.sentences.index(sentence)
			eq_id = stmt.index('=')
			if eq_id > 0:
				cpu_empty['return'].append(stmt[0])
#				if self.moved.count() 
# If a data array is not sent to gpu, we use it in cpu function
			func_name = stmt.index('cpu') + 2
			for i in stmt[func_name+2:-1]:
				if i is not ',':
					if self.arguments.count(i) > 0:
						cpu_empty['args'].append(i)
						if self.moved.count(i) > 0:
							cpu_empty['dtoh'].append(i)
					else:
						print "Pass the array accessed by the CPU function to Urutu Kernel"
			stmt.remove(stmt[func_name-2])
			stmt.remove(stmt[func_name-2])
			cpu_empty['src'] = stmt
			cpu_empty['isnext'] = False
			if len(self.cpu_info) == 0:
				self.run_gpu(self.kernel_final[-1])
				self.gpu_id+=1
				kernel = "__global__ void "+ self.global_func + "_" + str(self.gpu_id) + "(" + self.kernel_args + "){\n"
				self.ismap.append(True)
				self.threads_dec = [False, False, False]
				self.blocks_dec = [False, False, False]
				self.remove_workitems()
				self.kernel = kernel
			elif self.cpu_info[-1]['ln'] + 1 != cpu_empty['ln']:
				self.cpu_info[-1]['isnext'] = False
				print "Running on CPU"
				self.run_cpu()
				self.kernel_final.append(kernel+"}")
				self.gpu_id+=1
				kernel = "__global__ void "+ self.global_func + "_" + str(self.gpu_id) + "(" + self.kernel_args + "){\n"
				self.ismap.append(True)
				self.threads_dec = [False, False, False]
				self.blocks_dec = [False, False, False]
				self.remove_workitems()
				self.kernel = kernel
			elif self.cpu_info[-1]['ln'] + 1 == cpu_empty['ln']:
				self.cpu_info[-1]['isnext'] = True
			self.cpu_info.append(cpu_empty)
			return kernel

		if stmt.count('Urmod') > 0:
			self.num_mod = self.num_mod + 1
			self.modules.append(stmt[2:])
			self.kernel_final.append(kernel+"}")
			kernel = "__global__ void "+ self.global_func + "_" + str(len(self.modules)+1) + "(" + self.kernel_args + "){\n"
			self.ismap.append(True)
			self.threads_dec = [False, False, False]
			self.blocks_dec = [False, False, False]
			self.kernel = kernel
			return kernel
		else:
#			print "Entering Checkvars",phrase
			if(len(self.cpu_info)) > 0 and self.return_kernel == False:
				self.run_cpu()
			return self.checkvars(stmt,phrase[-1],kernel)
#		print stmt, self.tabs

	def Urmod(self,stmt,cu_args):
		id = stmt.index('(')
		function = stmt[id-1]
		module = stmt[id-3]
		string_args = [""]
		var = ""
		for i in stmt[id+1:-1]:
			if i is not ',':
				if self.arg_nam.count(i) > 0:
					string_args[-1] = "args[" + str(self.arg_nam.index(i)) + "]"
				elif i == 'size':
					size = self.args[self.arg_nam.index(stmt[stmt.index(i)-2])].size
					string_args[-1] = str(size)
				else:
					string_args[-1] += str(i)
			else:
				string_args.append("")
		modules.execute(module,function,string_args,cu_args)

	def device_create_func(self,index,name,stmt):
#		print "Inside DCF",name, stmt, self.device_py
		if self.is_defined_device[index] == False:
			device_keys = self.device_py[index]
			self.device_scope = True
#			print "Device Keys",device_keys
			is_dyn_parallel = False
			if stmt[stmt.index("(")+1] == "[" and stmt[stmt.index("(")+9] == "[":
#				print "Dynamic Parallelism"
				thread_index = stmt.index('(') + 1
				self.device_num_threads = [stmt[thread_index+1], stmt[thread_index+3], stmt[thread_index+5]]
				block_index = thread_index + 8
				self.device_num_blocks = [stmt[block_index+1], stmt[block_index+3], stmt[block_index+5]]
#				print self.device_num_threads , self.device_num_blocks
				stmt = stmt[:thread_index] + stmt[block_index+8:]
#				print stmt
				is_dyn_parallel = True
				self.device_dyn_p = True
			self.device_funcname(name,stmt[:],device_keys[device_keys.index('(')+1:device_keys.index(')')],True,is_dyn_parallel)
			index = self.device_func_name.index(name)
			for i in self.device_sentences[index]:
				self.device_body_buff = self.declare_workitems(i,self.device_body_buff)
#			print "Inside CREATING DEVICE BODY"
			for i in self.device_sentences[index]:
				self.device_body_buff = self.inspect_it(i,self.device_body_buff)
#			print self.device_body_buff
			self.device_scope = False
			self.kernel = self.device_body_buff + self.kernel
			self.device_threads_dec = [False, False, False]
			self.device_blocks_dec = [False, False, False]
			self.is_defined_device[index] = True
			if is_dyn_parallel == True:
				return self.dyn_parallel(stmt,name)+";\n"
			return self.stringize(stmt) + "; \n"
		return "/**/"

	def dyn_parallel(self,stmt,name):
		dimGrid = "dimGrid_"+str(name)
		dimBlock = "dimBlock_"+str(name)
		str_dec_blocks = "dim3 " + dimGrid + '(' + str(self.device_num_blocks[0]) + ',' + str(self.device_num_blocks[1]) + ',' + str(self.device_num_blocks[2]) + ");\n"
		str_dec_threads = "dim3 " + dimBlock + '(' + str(self.device_num_threads[0]) + ',' + str(self.device_num_threads[1]) + ',' + str(self.device_num_threads[2]) + ");\n"
		str_dyn_first = str(name) + '<<<' + dimGrid + ',' + dimBlock + '>>>'
		str_dyn_last = ""
		for i in stmt[1:]:
			str_dyn_last += str(i)
		return str_dec_blocks+str_dec_threads+str_dyn_first+str_dyn_last

	def device_funcname(self,func_name,stmt,args,device,is_dyn_parallel):
#		print "Inside device_funcname: ", stmt
		while ',' in args:
			args.remove(',')
		if is_dyn_parallel == True:
			self.device_body_buff = "__global__ "
		elif device == True:
			self.device_body_buff = "__device__ "
		index = stmt.index("(")
		tmp = " " + func_name + "("
		if self.device_func_name.count(stmt[0]) == 1:
			self.device_body_buff += "void "
		elif stmt[1] == "[":
			self.device_body_buff += self.type_vars[self.var_nam.index(stmt[0])][:-1]
		else:
			self.device_body_buff += self.type_vars[self.var_nam.index(stmt[0])]
		self.device_body_buff += tmp
#		print stmt,index
		idx = 0
		stmt[index], stmt[-1] = ',',','
		l=stmt.remove(stmt[0])
#		print args
		try:
			end_index = stmt.index(")")
		except:
			end_index = -1
		flag = True
		for j in range(len(stmt[index:end_index])):
			i = stmt[j+index]
			if i is not ",":
				if i is '[':
					flag = False
				if i is ']':
					flag = True
				if flag == True:
					if self.var_nam.count(i) == 1:
						if stmt[stmt.index(i)+1] == '[':
							type_var = self.type_vars[self.var_nam.index(i)][:-1]
							self.device_body_buff += type_var + " " + args[idx] + ", "
							self.device_var_nam[-1].append(args[idx])
							self.device_type_vars[-1].append(type_var)
						else:
							type_var = self.type_vars[self.var_nam.index(i)]
							self.device_body_buff += type_var + " " + args[idx] + ", "
							self.device_var_nam[-1].append(args[idx])
							self.device_type_vars[-1].append(type_var)
					else:
						if stmt[j+1+index] is '.' and stmt[j+index] != "blockDim":
							self.device_body_buff += "float " + args[idx] + ", "
							j+=2
							self.device_var_nam[-1].append(args[idx])
							self.device_type_vars[-1].append("float")
						elif type(stmt[j]) is int or stmt[j] is '-':
							self.device_body_buff += "int " + args[idx] + ", "
							self.device_var_nam[-1].append(args[idx])
							self.device_type_vars[-1].append("int")
			else:
				idx += 1
		dec_threads = True
		self.device_body_buff = self.device_body_buff[:-2]
		self.device_body_buff +="){\n"
#		print "DBB",self.device_body_buff

# convert the list into string
	def stringize(self, stmt):
		phrase = ''
		for i in stmt:
			phrase = phrase + str(i)
		return phrase


# Checking the type of variable to be created
	def checktype(self,var,val):
#		print var, val
		if val.count('.') == 1:
			return 'float ', self.stringize(var[:]) , '',  self.stringize(val[:])
		try:
			int(self.stringize(val))
			return 'int ', self.stringize(var[:]), '', self.stringize(val[:])
		except:
			if self.stringize(val).find('"') != -1:
				return 'char ', self.stringize(var[:]), '[]', self.stringize(val[:])
			elif self.stringize(val).find("'") != -1:
				val = str(val[0]).split("'")
				quote = ['"']
				quote.append(val[1])
				quote.append('"')
				return 'char ' , self.stringize(var[:]), '[]', self.stringize(quote)
			elif val.count('[') > 0 or var.count(']') > 0:
				if self.var_nam.count(var[0]) == 0 and self.device_scope == False:
					return self.type_vars[self.var_nam.index(val[0])][:-1],' ', self.stringize(var[:]), self.stringize(val[:])
				else:
					return '','',self.stringize(var[:]), self.stringize(val[:])
			elif val.count('+') > 0 or val.count('*') > 0 or val.count('-') > 0:
				if self.device_var_nam[-1].count(var[0]) == 0:
#					print device_var_nam[-1], var
					return 'int ', self.stringize(var[:]), '', self.stringize(val[:])
				if self.var_nam.count(var[0]) == 0 and self.device_scope == False:
					return 'int ', self.stringize(var[:]), '', self.stringize(val[:])
				else:
					return '','',self.stringize(var[:]), self.stringize(val[:])
			elif val.count('/') > 0:
				return 'float ', self.stringize(var[:]), '', self.stringize(val[:])
			elif self.var_nam.count(val[0]) > 0 and self.var_nam.count(var) == 0:
				id = self.var_nam.index(val[0])
				return self.stringize(self.type_vars[id]), '', self.stringize(var), self.stringize(val)
			elif val[0] == "int" or val[0] == "float":
				return val[0]+' ', '', self.stringize(var), self.stringize(val)
			else:
				return '','',self.stringize(var[:]), self.stringize(val[:])

# a = 10 type variables are declared here!
	def decvars(self,stmt,phrase,kernel):
#		print "Inside Dec vars",phrase,stmt
#		if kernel[-2] == '}':
#			kernel = kernel[:-2]
#			kernel += "\n"
		if stmt.count('return') == 1:
			kernel += phrase+";\n"
#			print "Adding return",kernel
			return kernel
		elif stmt.count('=') == 0:
			return kernel
		else:
			ideq = stmt.index('=')
			commavarid = [-1]
			commavalid = [ideq]
			if self.return_kernel == False:
				for i in range(len(stmt[ideq:])):
					if self.arguments.count(stmt[i+ideq]) > 0 and self.moved.count(stmt[i+ideq]) < 1:
						item = stmt[i + ideq]
						self.moved.append(item)
						self.cuda_exe.htod(item)
				self.moved.append(stmt[0])
			tmp = stmt
			for k in tmp:
				if k == ',' and tmp.index(k) < ideq:
					commavarid.append(tmp.index(k))
					tmp[tmp.index(k)] = ''
				if k == ',' and tmp.index(k) > ideq:
					commavalid.append(tmp.index(k))
					tmp[tmp.index(k)] = ''
#			print tmp
			commacount = len(commavarid)
			commavalid.append(len(tmp))
			commavarid.append(ideq)
			for i in range(commacount):
#				print self.var_nam
				if self.var_nam.count(i) == 0 and stmt.index('=') > i:
#					if self.device_var_nam[-1].count(stmt[commavarid[i]+1]) > 0:

					ret_checktype = self.checktype(stmt[commavarid[i]+1:commavarid[i+1]],stmt[commavalid[i]+1:commavalid[i+1]])
					kernel += ret_checktype[0] + ret_checktype[1] + ret_checktype[2] + "= " + ret_checktype[3] + ";\n"
					if self.device_scope == False:
						self.var_nam.append(ret_checktype[1])
						self.type_vars.append(ret_checktype[0])
					elif self.device_scope == True:
						self.device_var_nam[-1].append(ret_checktype[1])
						self.device_type_vars[-1].append(ret_checktype[0])
#			print "Exiting decvars",kernel
			return kernel

#	CHECKVARS here!!
	def checkvars(self,stmt,phrase,kernel):
#		print "Inside Check Vars",phrase, stmt
		if self.__shared.count(stmt[0]) == 1 and self.var_nam.count(stmt[0]) == 0:
			kernel, self.var_nam, self.type_vars = declare.decshared(stmt, self.type_vars, self.var_nam, self.args, kernel)
			return kernel
		elif self.__global.count(stmt[0]) == 1 and self.var_nam.count(stmt[0]) == 0:
			kernel, self.var_nam, self.type_vars = declare.decglobal(stmt, self.type_vars, self.var_nam, self.args, kernel)
			return kernel
		elif self.__register.count(stmt[0]) == 1 and self.var_nam.count(stmt[0]) == 0:
			kernel, self.var_nam, self.type_vars = declare.decregister(stmt, self.type_vars, self.var_nam, self.args, kernel)
			return kernel
		elif self.__constant.count(stmt[0]) == 1 and self.var_nam.count(stmt[0]) == 0:
			kernel, self.var_nam, self.type_vars = declare.decconstant(stmt, self.type_vars, self.var_nam, self.args, kernel)
			return kernel
		else:
			kernel = self.decvars(stmt,phrase,kernel)
		return kernel

# body (self) here!
	def body(self):
		for sentence in self.sentences:
			if sentence.split('\t')>1:
				phrase = sentence.split('\t')
				tabs = phrase.count('')
#				print "Inside Body",phrase, tabs
				sh = shlex.shlex(phrase[-1])
				i = sh.get_token()
#				print i
				if i == "def":
#					print "In DEF"
#					print self.device_py
					self.is_device_code = True
					self.is_defined_device.append(False)
					self.device_tab = tabs
					self.device_py.append([i])
					if self.device_py[0] == []:
						self.device_py.pop(0)
					i = sh.get_token()
					self.device_func_name.append(i)
#					print "DEC",self.device_func_name, self.device_py
					while i is not sh.eof:
						self.device_py[-1].append(i)
						i = sh.get_token()
					self.device_sentences.append([])
				elif self.device_tab < tabs and self.is_device_code == True:
					for j in phrase[tabs:]:
						self.device_sentences[-1].append(j)
					if self.device_sentences[0] == []:
						self.device_sentences.pop(0)
#					print "Body!!", self.device_py, self.device_sentences
				else:
					self.kernel = self.inspect_it(sentence,self.kernel)
		return

	def defargs(self,comma,control,kernel):
		if self.arguments.count(self.keys[control]) < 2:
			self.arguments.append(self.keys[control])
			kernel_arg = ""
			if comma == True:
				if "int64*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = ", long* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "long*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "int32*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = ", int* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "int*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "float32*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = ", float* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "float*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "float64*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = ", double* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "double*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "int" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = ", int " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "int"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "float" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = ", float " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "float"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
			elif comma == False:
				if "int64*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = " long* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "long*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "int32*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = " int* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "int*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "float32*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = " float* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "float*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "float64*" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = " double* " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "double*"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "int" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = " int " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "int"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
				elif "float" == self.type_args[len(self.arguments) - 1]:
					kernel_arg = " float " + self.keys[control]
					self.type_vars[len(self.arguments) - 1] = "float"
					self.arg_nam[-1] = self.keys[control]
					self.arg_nam.append("")
			self.kernel_args += kernel_arg
			kernel += kernel_arg
			self.var_nam.append(self.keys[control])
		return kernel

	def _for(self, words, kernel):
		iterator = words[1]
		if words.count('range') > 0:
			if words.count(',') == 0:
				ind = words.index('(')
				if words[ind+1] == "len":
					str_for = "for(int " + str(iterator)
					var_for = words[ind+3]
					str_for += " = 0; " + str(iterator) + " < sizeof(" + str(var_for) + ")/sizeof(" + str(var_for) + "[0])"
					if words[words[ind:].index(')')+ind+1] != ")":
						ind_closed = words[ind+1:].index(")")+ind+2
						ind_total_close = words[ind+1:].index(")")+ind_closed-1
						for i in range(ind_closed, ind_total_close):
							str_for += str(words[i])
						str_for += "; " + str(iterator) + "++){\n"
						type_var_for = str(self.type_vars[self.var_nam.index(var_for)][:-1])
						self.var_nam.append(str(iterator))
						self.type_vars.append(type_var_for)
				else:
					str_for = "for(int " + str(iterator)
					var_for = words[ind+3]
					str_for += " = 0; " + str(iterator) + " < "
					range_id = words.index("range")
					end_id = words.index(":")
					for i in range(range_id+1,end_id):
						str_for += str(words[i])
					str_for += "; " + str(iterator) + "++){\n"
#					type_var_for = str(self.type_vars[self.var_nam.index(var_for)][:-1])
#					self.var_nam.append(str(iterator))
#					self.type_vars.append(type_var_for)
#			if words.count(',')
		else:
			str_for = "for(int _" + str(iterator)
			var_for = words[words.index('in')+1]
			str_for += " = 0; " + "_"+str(iterator) + " < sizeof(" + str(var_for) + ")/sizeof(" + str(var_for) + "[0]); _" + str(iterator) + "++){\n"
			type_var_for = str(self.type_vars[self.var_nam.index(var_for)][:-1])
			str_for += type_var_for + " " + str(iterator) + " = " + str(var_for) + "[_" + str(iterator) + "];\n"
			self.var_nam.append(str(iterator))
			self.type_vars.append(type_var_for)
#			print self.type_vars, self.var_nam
		return str_for

	def get_cpusrc(self,src,func_nam):
		imp = src.split('import')
		tmp = ""
		for i in range(len(imp)):
			if i == len(imp)-1:
				tmp += imp[i].split('\n')[0] + '\n'
			else:
				tmp += imp[i] + "import"
		src = tmp + 'def ' + func_nam + src.split('def '+func_nam)[-1]
		src = src.split('\n\n')[0]
		return src
		

	def run_cpu(self):
		for k in range(len(self.cpu_info)):
			for j in self.cpu_info[k]['dtoh']:
				self.cuda_exe.dtoh(j)
				if j in self.moved:
					self.moved.remove(j)
			src = self.cpu_info[k]['src']
			eq_id = -1
			if src.count('=') > 0:
				eq_id = src.index('=')
			par_id = src.index("(")
			name = self.stringize(src[eq_id+1:par_id])
			load_stack = inspect.stack()
			f = open(str(load_stack[-1][1]),'r')
			code_global = compile(self.get_cpusrc(f.read(),name),'<string>','exec')
			exec code_global
			code = "self.args[self.arguments.index('"+self.stringize(src[0])+"')]"+self.stringize(src[1:eq_id+1]) + name
#			print getcallargs(average,self.args[0])
			for i in src[eq_id+2:]:
				if i in self.arguments:
					code = code + "self.args[self.arguments.index('"+str(i)+"')]"
				else:
					code = code + i
			exec code
		self.cpu_info = []

	def run_gpu(self,gpu_data):
		self.cuda_exe.exe_cu(gpu_data, self.global_func +"_"+str(self.gpu_id), self.threads, self.blocks, self.device_dyn_p, self.is_shared)

	def execute(self):
		self.cuda_exe = execu.cu_exe()
		sh = shlex.shlex(self.code)
		i = sh.get_token()
		self.keys = [i]
		while i is not sh.eof:
			i = sh.get_token()
			self.keys.append(i)
		self.num_return = self.keys.count('return')
		control = self.keys.index('def')
		control = self.funcname_cu(control)
		comma = False
		if self.keys[control] == '(':
			control = control+1
			while self.keys[control] != ')':
				if self.keys[control] == ',':
					control = control + 1
				self.kernel = self.defargs(comma, control, self.kernel)
#				print self.type_vars
				comma = True
				control = control + 1
			ret = len(self.keys) - self.keys[::-1].index('return')
			while self.keys[ret] != '':
				if self.keys[ret] == ',':
					ret = ret + 1
				self.returns.append(self.keys[ret])
				ret = ret + 1
			self.kernel = self.kernel + "){\n"
			control = control + 1
		if self.keys[control] == ':':
			control = control + 1
		self.sentences = self.code.split("\n")
		self.sentences.remove(self.sentences[1])
		self.sentences.remove(self.sentences[-2])
#		print self.kernel, "Entering body()"
		if self.return_kernel == False:
			np_args = []
			np_arg_nam = []
			for i in range(len(self.args)):
				if str(type(self.args[i])).find('numpy') != -1:
					np_args.append(self.args[i])
					np_arg_nam.append(self.arg_nam[i])
			self.cuda_exe.malloc(np_args,np_arg_nam)
		self.body()
		self.kernel = self.kernel + "}"
#		self.print_cu()
		self.arg_nam.pop(-1)
		self.kernel_final.append(self.kernel)
		if self.return_kernel == False:
			self.run_gpu(self.kernel_final[-1])
#			print self.kernel_final, len(self.kernel_final)
#			for i in range(len(self.kernel_final)):
#				if self.ismap[i] == False:
				
#				if self.num_mod > 0:
#					self.Urmod(self.modules[i],tmp.get_cu_args())
#					self.num_mod = self.num_mod - 1

			return self.cuda_exe.get_returns(self.returns, self.moved)
		elif self.return_kernel == True:
#			print self.ismap
			return self.kernel_final

	def print_cu(self):
		print "In print_cu:"
		print self.type_args
		print self.arguments
		print self.returns
		print self.var_nam
		print self.var_val
		print self.kernel
		print self.threads
		print self.blocks
		print self.func_name
		print self.code
		print self.words
		print self.sentences

